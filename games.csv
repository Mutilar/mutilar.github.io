ID,NAME,MOTTO,DATE,GITHUB,TEXT
bitnaughts,‚òÑ BitNaughts,Code Gamified,Ongoing,https://github.com/bitnaughts/bitnaughts,"<h3>The Idea</h3><p>BitNaughts is a free-to-play educational programming video game ‚Äî code gamified. Construct your object-oriented spaceship, learn programming to code your systems, and save the Earth from Martian invasion. Born from <a href='#iterate'>Iterate's</a> interpreter and refined across four consecutive Microsoft Hackathons, BitNaughts turns real coding into real gameplay.</p><h3>How It Works</h3><p>Built in Unity 6.0 with C#, the project is architected as a constellation of Git submodules ‚Äî a Unity project (<a href='https://github.com/bitnaughts/bitnaughts.unity'>bitnaughts.unity</a>), a custom C# interpreter (<a href='https://github.com/bitnaughts/bitnaughts.interpreter'>bitnaughts.interpreter</a>) that steps through each OP Code of abstracted languages, a WebGL front-end (<a href='https://github.com/bitnaughts/bitnaughts.github.io'>bitnaughts.github.io</a>) for browser-based play, a serverless Azure back-end (<a href='https://github.com/bitnaughts/bitnaughts.mainframe'>bitnaughts.mainframe</a>) for persistence, and separate repos for assets, UI/UX, and components. Players write actual code to control their ship's systems ‚Äî navigation, weapons, shields ‚Äî with the interpreter evaluating their programs in real time against the game's physics and combat engine.</p><h3>The Grind</h3><p>Four Microsoft Hackathon pitches ('20, '21, '22, '23) shaped the vision through iterative live-demo feedback, each year pushing the architecture further ‚Äî from a monolithic prototype to a fully modular, open-source game engine. The submodule architecture means contributors can clone, modify, and submit changes to any layer independently. The core challenge remains the same one Iterate cracked: making programming genuinely fun, not just gamified busywork. <a href='https://bitnaughts.io' target='_blank'>Play the demo ‚Üí</a></p>"
iterate,‚Ñπ Iterate,Code Mobilized,Ongoing,https://github.com/Mutilar/Iterate,"<h3>The Idea</h3><p>Most people learn to code by staring at a blank text editor and failing ‚Äî or by dragging blocks in Scratch and never writing a real line of code. Iterate bridges that gap: a mobile code editor that uses Java/Arduino syntax but lets you build programs through guided tap-based selections instead of raw typing. Built for UC Merced's CITRIS Mobile App Challenge, the pitch was simple ‚Äî put real programming in everyone's pocket.</p><h3>How It Works</h3><p>Built in Unity with C#, the entire app runs on a 1,300+ line CodeManager that acts as both editor and interpreter. Users tap a line to enter edit mode, then construct code through cascading option menus: Create Variable ‚Üí Integer/Double/Boolean/String ‚Üí name it ‚Üí assign a value. Flow control (if/else, while, for loops), Arduino hardware calls (pinMode, digitalWrite, analogRead, analogWrite, Serial.begin/print/println, servo.attach/write, delay, map), and variable scoping are all handled through the same tap-driven UI. A ColorCoder class provides real-time syntax highlighting ‚Äî keywords in blue, objects in teal, strings in amber, comments in green ‚Äî by injecting Unity rich text color tags on every frame. Pre-built lesson templates (Windmill, Servos, Stopwatch) load from Resources as starting scaffolds.</p><h3>The Grind</h3><p>The editor tracks variable scope by scanning every line above the cursor for declarations, dynamically populating only the valid options at each step ‚Äî you literally can't write a syntax error. The whole thing compiles to WebGL so it runs in-browser on any device. We took the $5,000 Grand Prize at the 2017 CITRIS Mobile App Challenge, beating out every team in the UC system. <a href='https://iterateco.de' target='_blank'>Try it live ‚Üí</a></p>"
seerauber,üß≠ SeeR√§uber,Pirating Code,December 2018,https://github.com/plebeiathon/seerauber,"<h3>The Idea</h3><p>In SeeR√§uber, logical mastery is only the first chapter of the story. You write code to build ships, direct fleets, and govern an empire ‚Äî but fate's hand, revealed through tarot, challenges your carefully laid plans. Each card draw brings new chaos, forcing you to adapt or embrace the unpredictable. Only those who balance logic and fortune will leave a lasting legacy.</p><h3>How It Works</h3><p>Built in Unity3D with C#, the game features a custom visual programming language ‚Äî drag-and-drop code blocks with loops, conditionals, tasks, and variables that control your pirate crew's AI. Each pirate has simulated needs (hunger, thirst, sleep, sailing) and an interpreter evaluates your nested code blocks to generate task queues in real time. A state machine tracks day/night cycles, combat, and sailing conditions, while procedurally generated pirate names and Shakespearean insults bring the crew to life.</p><h3>The Grind</h3><p>We built an entire code interpreter from scratch in 24 hours ‚Äî a recursive block evaluator that parses nested conditionals, loops, and boolean expressions to drive distributed pirate AI. Wiring up the drag-and-drop UI, the pirate need system, and the state machine into a cohesive game loop was a sprint, but we sailed out of SacHacks with a Second Place finish and a playable WebGL build.</p>"
graviton,üå∏ Graviton,Retro Sci-fi Tower Defense,2016,https://github.com/Mutilar/Graviton,"<h3>The Idea</h3><p>Classic arcade games like Space Invaders and Missile Command never stopped being fun ‚Äî they just stopped being made. Graviton mashes slow-descending alien swarms with strategic satellite defense into a retro sci-fi tower defense game, built from scratch at a hackathon and designed for Android.</p><h3>How It Works</h3><p>Built in Unity with C#, the game runs on a 630+ line GameManager that handles wave spawning, path generation, satellite placement, and an in-game economy. A ValuesManager defines 5 escalating levels ‚Äî each a procedurally timed sequence of ship deployments using randomized ship types with distinct scale, speed, and health values. Players purchase and place orbital satellites via a RocketManagement system that animates a multi-stage rocket launch to the target coordinates. Satellites come in 3 weapon tiers ‚Äî ConventionalRifle ($6), PlasmaCannon ($10), and LaserBeam ($14) ‚Äî each upgradeable for damage and range. A SatelliteManager handles turret rotation with predictive lead-target aiming, calculating intercept angles from projectile speed, distance, and enemy velocity. The ProjectileManager pools 6 projectile types (ConventionalRifle, ConventionalCannon, ConventionalFlakCannon, ConventionalMissile, LaserBeam, LaserCannon) plus 50 explosion instances with randomized animator controllers. An Intro scene plays a full sci-fi radio dialogue cutscene with a custom Scrambler text effect before dropping into gameplay. Paint.NET for sprites, Audacity for audio, 12+ ship sprite variants.</p><h3>The Grind</h3><p>Two thousand lines of C# in under two days. The lesson was build the skeleton first ‚Äî we burned hours on animations and sound effects that only slowed debugging. The win screen tells the story: 'The Scientists got the Graviton Accelerator running, repelling the Alien Invasion!' Starting from nothing and shipping a game with cutscenes, 5 winnable waves, upgrade trees, and pooled particle explosions in a hackathon window ‚Äî that's the kind of pressure that teaches you what to cut and what to keep.</p>"
spaceninjas,üïπÔ∏è SpaceNinjas,Intro to Game Design 2D Platformer,2015,https://github.com/Mutilar/SpaceNinjas,"<h3>The Idea</h3><p>Teaching game design means giving students something they can break apart and rebuild. SpaceNinjas is a 2D side-scrolling ninja platformer built as a boilerplate for Monte Vista's Summer of Game Design ‚Äî a ready-made Unity project students crack open on day one to learn C# through tweaking a working game instead of staring at blank scripts.</p><h3>How It Works</h3><p>Built in Unity 5 with C#, the repo ships two parallel script architectures. The first is a fully hardcoded reference game ‚Äî player.cs (269 lines), enemy.cs, enemyRanged.cs ‚Äî with every mechanic inline and heavily commented. A/D movement, W/Space jump via Rigidbody2D.AddForce, left-click sword swing using Physics2D.Raycast at 0.25 range, right-click throwing stars via Instantiate with starPhysics handling directional AddForce and rotation. Melee enemies chase via sight-distance detection and swing with raycasts; ranged enemies fire laser projectiles while keeping distance. The second architecture is a set of modular Person_ components ‚Äî Person_Health, Person_AttackMelee, Person_AttackRanged, Movement_SideScroller, Movement_TopDown, MovementAI_SideScroller, MovementAI_TopDown ‚Äî with public bool toggles (AI_enabled, SFX_enabled, death_reset, death_deletion) so students compose behaviors via the Unity Inspector without touching code. 3 HP hearts, 3 ammo stars, a cameraFollow script, moving island platforms, and a Dojo finish trigger round out the package.</p><h3>The Grind</h3><p>The dual-architecture approach ‚Äî one monolithic 'here is the whole game' script and one modular 'drag-and-drop behaviors' toolkit ‚Äî meant writing every system twice. But that's the teaching trick: students see the messy reality first, then learn why components exist. Every single line is commented like a textbook. The result is a codebase where a student who has never opened Unity can play a game in five minutes and start modifying it in ten.</p>"
voodoo,‚ú® VooDoo,Minion-Swarming Madness,2015,https://github.com/Mutilar/Voodoo,"<h3>The Idea</h3><p>What if you commanded an army but never swung a sword yourself? VooDoo is a 2D side-scrolling real-time strategy game where you spawn minions, set waypoints, and watch your tribal warband clash against waves of voodoo enemies across procedurally generated terrain ‚Äî then jump into direct WASD platformer control for boss fights.</p><h3>How It Works</h3><p>Built in Unity 5.6 with C#, the game features 4 unit types ‚Äî Farmers (fast cannon fodder), Soldiers (melee swords), Priests (ranged magic puffs), and Witchdoctors (hybrid ranged/melee elites). Click to set waypoints; units march, detect enemies via Physics2D.Raycast, and auto-attack with randomized cooldowns and 3-sound-effect pools. Enemies mirror the system via EnemyMovement.cs. A terrainAssetsRedux procedural generator builds slopes, flats, and transitions from grass/dirt sprite tiles with configurable jaggedness. The 11-level campaign spans 3 acts ‚Äî each ending with a boss fight where controls switch to direct WASD movement with double-tap sprinting, jump via AddForce, and Space-to-shoot puff projectiles. Boss 1 throws rotating ThrownSword projectiles that pierce multiple units. Boss 3 has a multi-phase platform fight with targeted explosions. A 16-phase interactive tutorial teaches spawning, waypoints, Towering strategy (stack ranged units), and Rushing strategy (melee flood). LevelSaver persists kill/death stats and progress. Continuous mode ramps spawn rate until inevitable defeat.</p><h3>The Grind</h3><p>Scope was the enemy. Scripted cutscenes with GUIText dialogue, quadratic-eased menu animations, persistent K/D tracking, procedural terrain, 3 unique boss fights, a full tutorial, and two game modes ‚Äî all in a student project. The death animation alone (pop up, rotate, ragdoll fall, 10-second cleanup) shows the obsessive polish. The codebase is messy and the variable names are irreverent, but every system ships and every level plays to completion.</p>"