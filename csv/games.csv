ID,NAME,MOTTO,DATE,GITHUB,PLAY,PLAY_W,PLAY_H,TEXT
popvuj,üìú PopVuj,City Builder,Ideation,,,,,"<h3>The Idea</h3><p><em>'This is the account of how all was in suspense, all calm, in silence; all motionless, quiet, and empty was the expanse of the sky.'</em> Inspired by the <a href='https://en.wikipedia.org/wiki/Popol_Vuh' target='_blank'>Popol Vuh</a>, the Mayan creation narrative. PopVuj is a god-sim where you rule from the heavens, shaping a minion village against rival civilizations through decrees, prophecy, and nature itself. You never lift a sword; you bend fate.</p><h3>How It Works</h3><p>The camera is the cosmology. Up into the skies is the seat of divine control: issue decrees, manipulate weather, survey your dominion. Down at the village floor you inspect growth, population, and influence the macro world. Zoom further into individual houses, chapels, and buildings to watch your people interact, worship, and live their lives. Combat draws from <a href='#games' onclick=""event.preventDefault(); navigateToModal('games','voodoo')"">VooDoo's</a> minion-swarming system; visuals target Aufstand-style 2.5D graphics. Gods act through second-hand tools: send prophets to deliver messages, smite the unreligious, unleash bears on heretics, summon rain, and shape weather. Minions have traits, personalities, and a genetics system; religiousness is heritable, so selective breeding lets you cultivate a pious (or rebellious) civilization across generations. More religion means more control but less freedom and less science; the tension is the game.</p><h3>The Grind</h3><p>The foundation is organized, modular code: clean separation of UIs, dialogue systems, minion AI, genetics, and world simulation. The scope is enormous. A macro-scale rival-village strategy layer, a micro-scale life simulation, and a divine intervention toolkit all need to work together. Early development is focused on getting the core minion loop (birth, traits, needs, faith, death) running before layering on god powers and inter-village warfare. The <a href='https://en.wikipedia.org/wiki/Popol_Vuh' target='_blank'>Popol Vuh</a> itself is the design document: Tzacol, Bitol, Alom, Qaholom tried mud, then wood, then finally corn to shape humanity. Expect a few failed prototypes before the corn catches.</p>"
bitnaughts,‚òÑ BitNaughts,Code Gamified,Spring 2020 - Fall 2025,https://github.com/bitnaughts/bitnaughts,https://bitnaughts.io,,,"<h3>The Idea</h3><p>BitNaughts is a free-to-play educational programming video game: code gamified. Construct your object-oriented spaceship, learn programming to code your systems, and save the Earth from Martian invasion. Born from <a href='#projects' onclick=""event.preventDefault(); navigateToModal('projects','iterate')"">Iterate's</a> interpreter and refined across four consecutive Microsoft Hackathons, BitNaughts turns real coding into real gameplay.</p><h3>How It Works</h3><p>Built in Unity 6.0 with C#, the project is organized as a set of Git submodules: a Unity project (<a href='https://github.com/bitnaughts/bitnaughts.unity'>bitnaughts.unity</a>), a custom C# interpreter (<a href='https://github.com/bitnaughts/bitnaughts.interpreter'>bitnaughts.interpreter</a>) that steps through each OP Code of abstracted languages, a WebGL front-end (<a href='https://github.com/bitnaughts/bitnaughts.github.io'>bitnaughts.github.io</a>) for browser-based play, a serverless Azure back-end (<a href='https://github.com/bitnaughts/bitnaughts.mainframe'>bitnaughts.mainframe</a>) for persistence, and separate repos for assets, UI/UX, and components. Players write actual code to control their ship's systems (navigation, weapons, shields) with the interpreter evaluating their programs in real time against the game's physics and combat engine.</p><h3>The Grind</h3><p>Four Microsoft Hackathon pitches ('20, '21, '22, '23) shaped the vision through iterative live-demo feedback, each year pushing the architecture further: from a monolithic prototype to a fully modular, open-source game engine. The submodule architecture means contributors can clone, modify, and submit changes to any layer independently. The core challenge remains the same one Iterate cracked: making programming genuinely fun, not just gamified busywork. <a href='https://bitnaughts.io' target='_blank'>Play the demo ‚Üí</a></p>"
graviton,üå∏ Graviton,Tower Defense,September 2016,https://github.com/Mutilar/Graviton,games/Graviton/index.html,1080,1920,"<h3>The Idea</h3><p>Classic arcade games like Space Invaders and Missile Command never stopped being fun; they just stopped being made. Graviton combines slow-descending alien swarms with strategic satellite defense: a retro sci-fi tower defense game built from scratch at a hackathon.</p><figure class='modal-figure'><img src='images/graviton-menu.png' alt='Graviton menu screen'></figure><h3>How It Works</h3><p>Built in Unity with C#. A 630+ line GameManager handles wave spawning, path generation, satellite placement, and an in-game economy. 5 escalating levels, each a procedurally timed sequence of ship deployments using randomized ship types with distinct scale, speed, and health values. Players purchase and place orbital satellites via a rocket launch animation system. Satellites come in 3 weapon tiers (ConventionalRifle, PlasmaCannon, LaserBeam), each upgradeable for damage and range. Turret rotation uses predictive lead-target aiming, calculating intercept angles from projectile speed, distance, and enemy velocity. The ProjectileManager pools 6 projectile types plus 50 explosion instances with randomized animator controllers. An intro scene plays a radio dialogue cutscene with a Scrambler text effect before dropping into gameplay. Sprites in Paint.NET, audio in Audacity, 12+ ship variants.</p><figure class='modal-figure'><img src='images/graviton-gameplay.png' alt='Graviton gameplay'></figure><h3>The Grind</h3><p>Two thousand lines of C# in under two days. The lesson: build the skeleton first. We burned hours on animations and sound effects that only slowed debugging. The win screen says it all: 'The Scientists got the Graviton Accelerator running, repelling the Alien Invasion!' Starting from nothing and shipping a game with cutscenes, 5 winnable waves, upgrade trees, and pooled particle explosions in a hackathon window teaches you what to cut and what to keep.</p>"
spaceninjas,üïπÔ∏è SpaceNinjas,2D Platformer,Spring 2015,https://github.com/Mutilar/SpaceNinjas,games/SpaceNinjas/index.html,960,522,"<h3>The Idea</h3><p>Teaching game design means giving students something they can break apart and rebuild. SpaceNinjas is a 2D side-scrolling ninja platformer built as a boilerplate for Monte Vista's Summer of Game Design: a ready-made Unity project students crack open on day one to learn C# by tweaking a working game instead of staring at blank scripts.</p><figure class='modal-figure'><img src='images/spaceninjas-start.png' alt='SpaceNinjas start screen'></figure><h3>How It Works</h3><p>Built in Unity 5 with C#. The repo ships two parallel script architectures. The first is a fully hardcoded reference game (player.cs at 269 lines, enemy.cs, enemyRanged.cs) with every mechanic inline and heavily commented: A/D movement, W/Space jump via Rigidbody2D.AddForce, left-click sword swing using Physics2D.Raycast, right-click throwing stars via Instantiate. Melee enemies chase via sight-distance detection and swing with raycasts; ranged enemies fire laser projectiles while keeping distance. The second architecture is a set of modular Person_ components (Person_Health, Person_AttackMelee, Person_AttackRanged, Movement_SideScroller, Movement_TopDown, MovementAI_SideScroller, MovementAI_TopDown) with public bool toggles (AI_enabled, SFX_enabled, death_reset, death_deletion) so students compose behaviors via the Unity Inspector without touching code. 3 HP hearts, 3 ammo stars, a cameraFollow script, moving island platforms, and a Dojo finish trigger round out the package.</p><figure class='modal-figure'><img src='images/spaceninjas-end.png' alt='SpaceNinjas end screen'></figure><h3>The Grind</h3><p>The dual-architecture approach (one monolithic 'here is the whole game' script and one modular 'drag-and-drop behaviors' toolkit) meant writing every system twice. But that's the teaching trick: students see the messy reality first, then learn why components exist. Every line is commented like a textbook. A student who has never opened Unity can play the game in five minutes and start modifying it in ten.</p>"
voodoo,‚ú® VooDoo,Side-Scrolling Auto-Battler,Winter 2014 - Spring 2015,https://github.com/Mutilar/Voodoo,games/Voodoo/index.html,1024,768,"<h3>The Idea</h3><p>VooDoo is a side-scrolling lane-pusher in the spirit of <em>Age of War</em>: you spawn pixel-art warriors, set their waypoints across procedurally generated terrain, and watch your tribe clash with waves of voodoo-cursed enemies. You never fight directly; you point and your warband marches. When only the boss remains, you take direct platformer control.</p><figure class='modal-figure'><img src='images/voodoo-menu.png' alt='VooDoo menu screen'></figure><h3>How It Works</h3><p>Four warrior classes: shield-bearing Farmers, sword-wielding Soldiers, spell-casting Priests, and elite horned Witchdoctors, each hand-sprited with idle, march, and attack animations. Click the terrain to set waypoints; your minions march, fight, and die on their own. The battlefield is procedurally assembled from tile-sets of grassy slopes, dirt flats, and jagged transitions, so no two levels look the same. An 11-level campaign across 3 acts builds to boss encounters where the game switches genres: direct platformer control, dodging thrown swords and targeted explosions in multi-phase arena fights. Two complementary tactics emerge: <em>Towering</em> (stack ranged units behind melee walls) and <em>Rushing</em> (flood the lane with expendable fighters). A continuous survival mode ramps the spawn rate until your tribe finally falls.</p><figure class='modal-figure'><img src='images/voodoo-final.png' alt='VooDoo final boss'></figure><h3>The Grind</h3><p>Hand-animated in Paint.NET from open-source assets: four warrior classes across multiple animation states, three tiers of enemies, and three distinct bosses. Scripted cutscenes, a 16-phase interactive tutorial, and persistent kill/death tracking across all 11 levels. Way too big for a student project. The scope was absurd, the variable names are irreverent, and the codebase has scars; but every level plays to completion and every boss goes down.</p>"
galconq,üåå GalConq,Procedural Space Strategy,Fall 2014,,,,,"<h3>The Idea</h3><p>A 4X-style space strategy game where you manage star systems, trade routes, and fleets across a procedurally generated galaxy. Enter orbit to buy and sell ships, send convoys to trade scrap and materials, hire employees and gather intel. Originally built in VB.NET with WinForms as a high-school project.</p><h3>How It Works</h3><p>The original 2014 build used VB.NET and WinForms: a procedural 10√ó10 tile grid of star systems with point-and-click navigation, resource management, and fleet command rendered entirely in GDI+. Each star system offered orbital docking (buy/sell ships, manage cargo), convoy routing (trade scrap, materials, and damaged ships between systems), and crew management (hire employees, find mechanics, gather gossip and trade information). The Unity port expanded the scope from 100 fixed tiles to thousands of procedurally generated stars, nebulae, and clusters, with galaxy-wide parameter tuning for the procedural engine: star density, cluster distribution, resource scarcity, and faction territories all configurable.</p><h3>The Grind</h3><p>Galactic Conquest was the origin point. The procedural generation engine and the dream of coding-as-gameplay planted the seeds that grew into <a href='#projects' onclick=""event.preventDefault(); navigateToModal('projects','iterate')"">Iterate's</a> interpreter and eventually <a href='#games' onclick=""event.preventDefault(); navigateToModal('games','bitnaughts')"">BitNaughts</a>. Development paused when the vision shifted; rather than building another space game, the real value was in morphing the project toward educational programming, filling the procedural universe with player-written code instead of scripted AI. The VB.NET prototype proved the concept; BitNaughts is where it landed.</p>"
