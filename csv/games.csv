ID,NAME,MOTTO,DATE,GITHUB,PLAY,PLAY_W,PLAY_H,TEXT
bitnaughts,‚òÑ BitNaughts,Code Gamified,Ongoing,https://github.com/bitnaughts/bitnaughts,https://bitnaughts.io,,,"<h3>The Idea</h3><p>BitNaughts is a free-to-play educational programming video game ‚Äî code gamified. Construct your object-oriented spaceship, learn programming to code your systems, and save the Earth from Martian invasion. Born from <a href='#iterate'>Iterate's</a> interpreter and refined across four consecutive Microsoft Hackathons, BitNaughts turns real coding into real gameplay.</p><h3>How It Works</h3><p>Built in Unity 6.0 with C#, the project is architected as a constellation of Git submodules ‚Äî a Unity project (<a href='https://github.com/bitnaughts/bitnaughts.unity'>bitnaughts.unity</a>), a custom C# interpreter (<a href='https://github.com/bitnaughts/bitnaughts.interpreter'>bitnaughts.interpreter</a>) that steps through each OP Code of abstracted languages, a WebGL front-end (<a href='https://github.com/bitnaughts/bitnaughts.github.io'>bitnaughts.github.io</a>) for browser-based play, a serverless Azure back-end (<a href='https://github.com/bitnaughts/bitnaughts.mainframe'>bitnaughts.mainframe</a>) for persistence, and separate repos for assets, UI/UX, and components. Players write actual code to control their ship's systems ‚Äî navigation, weapons, shields ‚Äî with the interpreter evaluating their programs in real time against the game's physics and combat engine.</p><h3>The Grind</h3><p>Four Microsoft Hackathon pitches ('20, '21, '22, '23) shaped the vision through iterative live-demo feedback, each year pushing the architecture further ‚Äî from a monolithic prototype to a fully modular, open-source game engine. The submodule architecture means contributors can clone, modify, and submit changes to any layer independently. The core challenge remains the same one Iterate cracked: making programming genuinely fun, not just gamified busywork. <a href='https://bitnaughts.io' target='_blank'>Play the demo ‚Üí</a></p>"
popolVuh,üìú PopolVuh,Minion Madness v2,In Development,,,,,"<h3>The Idea</h3><p><em>'This is the account of how all was in suspense, all calm, in silence; all motionless, quiet, and empty was the expanse of the sky.'</em> ‚Äî Inspired by the <a href='https://en.wikipedia.org/wiki/Popol_Vuh' target='_blank'>Popol Vuh</a>, the Mayan creation narrative, Popol Vuh is a god-sim where you rule from the heavens, shaping a minion village against rival civilizations through decrees, prophecy, and nature itself ‚Äî never lifting a sword, only bending fate.</p><h3>How It Works</h3><p>The camera is the cosmology. Upwards into the skies is the seat of divine control ‚Äî the heavens UI where you issue decrees, manipulate weather, and survey your dominion. Down at the village floor you inspect growth, population, and influence the macro world. Zoom further into individual houses, chapels, and buildings to watch your people interact, worship, and live their lives. Combat draws from <a href='#voodoo'>VooDoo's</a> minion-swarming system; visuals target Aufstand-style 2.5D graphics. Gods act through second-hand tools: send prophets to deliver messages, smite the unreligious, unleash bears on heretics, summon rain, shape weather, and engineer divine interventions. Minions have traits, personalities, and a genetics system ‚Äî religiousness is heritable, so selective breeding lets you cultivate a pious (or rebellious) civilization across generations. More religion means more control but less freedom and less science; the tension is the game.</p><h3>The Grind</h3><p>The foundation is organized, modular code ‚Äî clean separation of UIs, dialogue systems, minion AI, genetics, and world simulation. The scope is enormous: a macro-scale rival-village strategy layer, a micro-scale life simulation, and a divine intervention toolkit all woven together. Early development is focused on getting the core minion loop ‚Äî birth, traits, needs, faith, death ‚Äî running before layering on the god powers and inter-village warfare. The <a href='https://en.wikipedia.org/wiki/Popol_Vuh' target='_blank'>Popol Vuh</a> itself is the design document: Tzacol, Bitol, Alom, Qaholom ‚Äî the Creators and the Makers ‚Äî tried mud, then wood, then finally corn to shape humanity. Expect a few failed prototypes before the corn catches.</p>"
seerauber,üß≠ SeeR√§uber,Pirating Code,December 2018,https://github.com/plebeiathon/seerauber,,,,"<h3>The Idea</h3><p>In SeeR√§uber, logical mastery is only the first chapter of the story. You write code to build ships, direct fleets, and govern an empire ‚Äî but fate's hand, revealed through tarot, challenges your carefully laid plans. Each card draw brings new chaos, forcing you to adapt or embrace the unpredictable. Only those who balance logic and fortune will leave a lasting legacy.</p><h3>How It Works</h3><p>Built in Unity3D with C#, the game features a custom visual programming language ‚Äî drag-and-drop code blocks with loops, conditionals, tasks, and variables that control your pirate crew's AI. Each pirate has simulated needs (hunger, thirst, sleep, sailing) and an interpreter evaluates your nested code blocks to generate task queues in real time. A state machine tracks day/night cycles, combat, and sailing conditions, while procedurally generated pirate names and Shakespearean insults bring the crew to life.</p><h3>The Grind</h3><p>We built an entire code interpreter from scratch in 24 hours ‚Äî a recursive block evaluator that parses nested conditionals, loops, and boolean expressions to drive distributed pirate AI. Wiring up the drag-and-drop UI, the pirate need system, and the state machine into a cohesive game loop was a sprint, but we sailed out of SacHacks with a Second Place finish and a playable WebGL build.</p>"
graviton,üå∏ Graviton,Retro Sci-fi Tower Defense,2016,https://github.com/Mutilar/Graviton,games/Graviton/index.html,1080,1920,"<h3>The Idea</h3><p>Classic arcade games like Space Invaders and Missile Command never stopped being fun ‚Äî they just stopped being made. Graviton mashes slow-descending alien swarms with strategic satellite defense into a retro sci-fi tower defense game, built from scratch at a hackathon and designed for Android.</p><h3>How It Works</h3><p>Built in Unity with C#, the game runs on a 630+ line GameManager that handles wave spawning, path generation, satellite placement, and an in-game economy. A ValuesManager defines 5 escalating levels ‚Äî each a procedurally timed sequence of ship deployments using randomized ship types with distinct scale, speed, and health values. Players purchase and place orbital satellites via a RocketManagement system that animates a multi-stage rocket launch to the target coordinates. Satellites come in 3 weapon tiers ‚Äî ConventionalRifle ($6), PlasmaCannon ($10), and LaserBeam ($14) ‚Äî each upgradeable for damage and range. A SatelliteManager handles turret rotation with predictive lead-target aiming, calculating intercept angles from projectile speed, distance, and enemy velocity. The ProjectileManager pools 6 projectile types (ConventionalRifle, ConventionalCannon, ConventionalFlakCannon, ConventionalMissile, LaserBeam, LaserCannon) plus 50 explosion instances with randomized animator controllers. An Intro scene plays a full sci-fi radio dialogue cutscene with a custom Scrambler text effect before dropping into gameplay. Paint.NET for sprites, Audacity for audio, 12+ ship sprite variants.</p><h3>The Grind</h3><p>Two thousand lines of C# in under two days. The lesson was build the skeleton first ‚Äî we burned hours on animations and sound effects that only slowed debugging. The win screen tells the story: 'The Scientists got the Graviton Accelerator running, repelling the Alien Invasion!' Starting from nothing and shipping a game with cutscenes, 5 winnable waves, upgrade trees, and pooled particle explosions in a hackathon window ‚Äî that's the kind of pressure that teaches you what to cut and what to keep.</p>"
spaceninjas,üïπÔ∏è SpaceNinjas,Intro to Game Design 2D Platformer,2015,https://github.com/Mutilar/SpaceNinjas,games/SpaceNinjas/index.html,960,522,"<h3>The Idea</h3><p>Teaching game design means giving students something they can break apart and rebuild. SpaceNinjas is a 2D side-scrolling ninja platformer built as a boilerplate for Monte Vista's Summer of Game Design ‚Äî a ready-made Unity project students crack open on day one to learn C# through tweaking a working game instead of staring at blank scripts.</p><h3>How It Works</h3><p>Built in Unity 5 with C#, the repo ships two parallel script architectures. The first is a fully hardcoded reference game ‚Äî player.cs (269 lines), enemy.cs, enemyRanged.cs ‚Äî with every mechanic inline and heavily commented. A/D movement, W/Space jump via Rigidbody2D.AddForce, left-click sword swing using Physics2D.Raycast at 0.25 range, right-click throwing stars via Instantiate with starPhysics handling directional AddForce and rotation. Melee enemies chase via sight-distance detection and swing with raycasts; ranged enemies fire laser projectiles while keeping distance. The second architecture is a set of modular Person_ components ‚Äî Person_Health, Person_AttackMelee, Person_AttackRanged, Movement_SideScroller, Movement_TopDown, MovementAI_SideScroller, MovementAI_TopDown ‚Äî with public bool toggles (AI_enabled, SFX_enabled, death_reset, death_deletion) so students compose behaviors via the Unity Inspector without touching code. 3 HP hearts, 3 ammo stars, a cameraFollow script, moving island platforms, and a Dojo finish trigger round out the package.</p><h3>The Grind</h3><p>The dual-architecture approach ‚Äî one monolithic 'here is the whole game' script and one modular 'drag-and-drop behaviors' toolkit ‚Äî meant writing every system twice. But that's the teaching trick: students see the messy reality first, then learn why components exist. Every single line is commented like a textbook. The result is a codebase where a student who has never opened Unity can play a game in five minutes and start modifying it in ten.</p>"
voodoo,‚ú® VooDoo,Minion-Swarming Madness,2015,https://github.com/Mutilar/Voodoo,games/Voodoo/index.html,1024,768,"<h3>The Idea</h3><p>What if you commanded an army but never swung a sword yourself? VooDoo is a 2D side-scrolling real-time strategy game where you spawn minions, set waypoints, and watch your tribal warband clash against waves of voodoo enemies across procedurally generated terrain ‚Äî then jump into direct WASD platformer control for boss fights.</p><h3>How It Works</h3><p>Built in Unity 5.6 with C#, the game features 4 unit types ‚Äî Farmers (fast cannon fodder), Soldiers (melee swords), Priests (ranged magic puffs), and Witchdoctors (hybrid ranged/melee elites). Click to set waypoints; units march, detect enemies via Physics2D.Raycast, and auto-attack with randomized cooldowns and 3-sound-effect pools. Enemies mirror the system via EnemyMovement.cs. A terrainAssetsRedux procedural generator builds slopes, flats, and transitions from grass/dirt sprite tiles with configurable jaggedness. The 11-level campaign spans 3 acts ‚Äî each ending with a boss fight where controls switch to direct WASD movement with double-tap sprinting, jump via AddForce, and Space-to-shoot puff projectiles. Boss 1 throws rotating ThrownSword projectiles that pierce multiple units. Boss 3 has a multi-phase platform fight with targeted explosions. A 16-phase interactive tutorial teaches spawning, waypoints, Towering strategy (stack ranged units), and Rushing strategy (melee flood). LevelSaver persists kill/death stats and progress. Continuous mode ramps spawn rate until inevitable defeat.</p><h3>The Grind</h3><p>Scope was the enemy. Scripted cutscenes with GUIText dialogue, quadratic-eased menu animations, persistent K/D tracking, procedural terrain, 3 unique boss fights, a full tutorial, and two game modes ‚Äî all in a student project. The death animation alone (pop up, rotate, ragdoll fall, 10-second cleanup) shows the obsessive polish. The codebase is messy and the variable names are irreverent, but every system ships and every level plays to completion.</p>"